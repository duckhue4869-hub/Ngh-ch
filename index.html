<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Controlled - Clockwise Rotation</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Segoe UI", sans-serif;
      }

      #input_video {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 160px;
        height: 120px;
        border-radius: 8px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        transform: scaleX(-1);
        z-index: 2;
        opacity: 0.6;
      }

      #ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(20, 20, 20, 0.9);
        padding: 20px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        z-index: 10;
        width: 220px;
      }

      h2 {
        margin: 0 0 10px 0;
        font-size: 16px;
        font-weight: 600;
        color: #fff;
      }
      p {
        font-size: 13px;
        color: #bbb;
        margin-bottom: 15px;
        line-height: 1.5;
      }
      .instruction {
        font-size: 12px;
        color: #00ffff;
        margin-bottom: 10px;
        font-style: italic;
      }

      input[type="color"] {
        -webkit-appearance: none;
        border: none;
        width: 100%;
        height: 30px;
        border-radius: 4px;
        cursor: pointer;
        padding: 0;
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ffff;
        font-size: 18px;
        z-index: 20;
        font-family: monospace;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="loading">ƒêANG KH·ªûI T·∫†O H·ªÜ TH·ªêNG...</div>

    <div id="ui-container">
      <h2>Ch·∫ø ƒë·ªô Kim ƒê·ªìng H·ªì</h2>
      <p>
        ‚ÜîÔ∏è <b>Kho·∫£ng c√°ch:</b> Ph√≥ng to/nh·ªè<br />
        üîÑ <b>Nghi√™ng tay:</b> Xoay C√πng/Ng∆∞·ª£c chi·ªÅu kim ƒë·ªìng h·ªì
      </p>
      <div class="instruction">ƒê∆∞a 2 tay l√™n ƒë·ªÉ ƒëi·ªÅu khi·ªÉn</div>
      <div style="margin-top: 10px">
        <span style="font-size: 12px">M√†u h·∫°t:</span>
        <input type="color" id="colorPicker" value="#ff0055" />
      </div>
    </div>

    <video id="input_video"></video>
    <div id="canvas-container"></div>

    <script>
      // --- 1. SETUP THREE.JS ---
      const scene = new THREE.Scene();
      // Gi·∫£m s∆∞∆°ng m√π ƒë·ªÉ n·ªÅn ƒëen s√¢u h∆°n
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 90;

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // --- 2. T·∫†O H·ªÜ TH·ªêNG H·∫†T ---
      const particleCount = 6000;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const radius = 35;

      for (let i = 0; i < particleCount; i++) {
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;
        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(phi);
        positions.push(x, y, z);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3)
      );

      const material = new THREE.PointsMaterial({
        color: 0xff0055, // M√†u m·∫∑c ƒë·ªãnh m·ªõi
        size: 1.0,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- 3. BI·∫æN LOGIC ---
      let targetScale = 1;
      let currentScale = 1;

      let targetRotationZ = 0; // Quay l·∫°i tr·ª•c Z (Kim ƒë·ªìng h·ªì)
      let currentRotationZ = 0;

      let isHandDetected = false;

      // --- 4. X·ª¨ L√ù MEDIAPIPE ---
      const videoElement = document.getElementById("input_video");

      function onResults(results) {
        document.getElementById("loading").style.opacity = 0;

        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length === 2
        ) {
          isHandDetected = true;

          let landmarks = results.multiHandLandmarks;
          // S·∫Øp x·∫øp tay tr√°i/ph·∫£i theo tr·ª•c X
          landmarks.sort((a, b) => a[8].x - b[8].x);

          const leftHand = landmarks[0][8];
          const rightHand = landmarks[1][8];

          // --- SCALE ---
          const distance = Math.sqrt(
            Math.pow(leftHand.x - rightHand.x, 2) +
              Math.pow(leftHand.y - rightHand.y, 2)
          );

          const minScale = 0.5;
          const maxScale = 4.5;
          let normalizedDist = (distance - 0.1) / (0.6 - 0.1);
          normalizedDist = Math.max(0, Math.min(1, normalizedDist));
          targetScale = minScale + normalizedDist * (maxScale - minScale);

          // --- ROTATION (CLOCKWISE / Z-AXIS) ---
          const dy = rightHand.y - leftHand.y;
          const dx = rightHand.x - leftHand.x;

          // T√≠nh g√≥c nghi√™ng
          const angle = Math.atan2(dy, dx);

          // Gi·∫£i th√≠ch Logic:
          // Tr·ª•c Y m√†n h√¨nh h∆∞·ªõng xu·ªëng.
          // N·∫øu tay Ph·∫£i th·∫•p h∆°n tay Tr√°i => dy > 0 => angle > 0.
          // Tr·∫°ng th√°i n√†y gi·ªëng nghi√™ng v√¥ lƒÉng sang ph·∫£i (Chi·ªÅu kim ƒë·ªìng h·ªì).
          // Trong ThreeJS: Rotation Z d∆∞∆°ng l√† Ng∆∞·ª£c chi·ªÅu KƒêH, √Çm l√† C√πng chi·ªÅu KƒêH.
          // V√¨ v·∫≠y ta l·∫•y -angle ƒë·ªÉ: Nghi√™ng Ph·∫£i -> angle d∆∞∆°ng -> Z √¢m -> Quay chi·ªÅu KƒêH.
          targetRotationZ = -angle;
        } else {
          isHandDetected = false;
          targetScale = 1;
        }
      }

      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      hands.onResults(onResults);

      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({ image: videoElement }),
        width: 640,
        height: 480,
      });
      cameraUtils.start();

      document.getElementById("colorPicker").addEventListener("input", (e) => {
        material.color.set(e.target.value);
      });

      // --- 5. ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);

        if (isHandDetected) {
          // Lerp Scale
          currentScale += (targetScale - currentScale) * 0.1;

          // Lerp Rotation Z (Kim ƒë·ªìng h·ªì)
          // D√πng c√¥ng th·ª©c n·ªôi suy g√≥c ng·∫Øn nh·∫•t ƒë·ªÉ xoay m∆∞·ª£t m√†
          currentRotationZ += (targetRotationZ - currentRotationZ) * 0.1;
          particles.rotation.z = currentRotationZ;

          // Reset tr·ª•c Y v·ªÅ 0 (ƒë·ªÉ kh√¥ng c√≤n xoay ngang)
          particles.rotation.y += (0 - particles.rotation.y) * 0.05;
        } else {
          // Idle Mode
          const time = Date.now() * 0.001;
          const breathe = Math.sin(time) * 0.05;

          currentScale += (1 - currentScale) * 0.05;
          particles.scale.set(
            currentScale + breathe,
            currentScale + breathe,
            currentScale + breathe
          );

          // T·ª± xoay nh·∫π
          particles.rotation.y += 0.002;
          particles.rotation.z += 0.001;

          // Sync v·ªã tr√≠ ƒë·ªÉ kh√¥ng gi·∫≠t khi ƒë∆∞a tay v√†o l·∫°i
          currentRotationZ = particles.rotation.z;
        }

        particles.scale.set(currentScale, currentScale, currentScale);
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
