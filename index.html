<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Controlled Particles - Horizontal Rotation</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: "Segoe UI", sans-serif;
      }

      #input_video {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 160px;
        height: 120px;
        border-radius: 8px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        transform: scaleX(-1);
        z-index: 2;
        opacity: 0.6;
      }

      #ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(30, 30, 30, 0.85);
        padding: 20px;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        width: 220px;
      }

      h2 {
        margin: 0 0 10px 0;
        font-size: 16px;
        font-weight: 600;
        color: #fff;
      }
      p {
        font-size: 13px;
        color: #ccc;
        margin-bottom: 15px;
        line-height: 1.5;
      }
      .instruction {
        font-size: 12px;
        color: #888;
        margin-bottom: 10px;
        font-style: italic;
      }

      .control-group {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 10px;
      }
      input[type="color"] {
        -webkit-appearance: none;
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        padding: 0;
        overflow: hidden;
      }
      input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 50%;
        border: 2px solid #fff;
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ffff;
        font-size: 18px;
        z-index: 20;
        pointer-events: none;
        transition: opacity 0.5s;
        font-family: monospace;
        letter-spacing: 2px;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="loading">ƒêANG T·∫¢I AI...</div>

    <div id="ui-container">
      <h2>ƒêi·ªÅu khi·ªÉn H·∫°t 3D</h2>
      <p>
        ‚ÜîÔ∏è <b>Kho·∫£ng c√°ch:</b> Ph√≥ng to/nh·ªè<br />
        üîÑ <b>Nghi√™ng tay:</b> Xoay ngang (Tr√°i/Ph·∫£i)
      </p>
      <div class="instruction">ƒê∆∞a 2 tay l√™n camera ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
      <div class="control-group">
        <span>M√†u s·∫Øc:</span>
        <input type="color" id="colorPicker" value="#00ffff" />
      </div>
    </div>

    <video id="input_video"></video>
    <div id="canvas-container"></div>

    <script>
      // --- 1. SETUP THREE.JS ---
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050505, 0.002);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 90;

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // --- 2. T·∫†O H·ªÜ TH·ªêNG H·∫†T ---
      const particleCount = 5000;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const radius = 30;

      for (let i = 0; i < particleCount; i++) {
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;
        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(phi);
        positions.push(x, y, z);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3)
      );

      const material = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 1.2,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- 3. BI·∫æN LOGIC ---
      let targetScale = 1;
      let currentScale = 1;

      let targetRotationY = 0; // ƒê·ªïi th√†nh Y ƒë·ªÉ xoay ngang
      let currentRotationY = 0;

      let isHandDetected = false;

      // --- 4. X·ª¨ L√ù MEDIAPIPE ---
      const videoElement = document.getElementById("input_video");

      function onResults(results) {
        document.getElementById("loading").style.opacity = 0;

        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length === 2
        ) {
          isHandDetected = true;

          let landmarks = results.multiHandLandmarks;
          // S·∫Øp x·∫øp tay tr√°i/ph·∫£i theo tr·ª•c X ƒë·ªÉ t√≠nh to√°n chu·∫©n
          landmarks.sort((a, b) => a[8].x - b[8].x);

          const leftHand = landmarks[0][8];
          const rightHand = landmarks[1][8];

          // --- X·ª¨ L√ù SCALE ---
          const distance = Math.sqrt(
            Math.pow(leftHand.x - rightHand.x, 2) +
              Math.pow(leftHand.y - rightHand.y, 2)
          );

          const minScale = 0.5;
          const maxScale = 4.5;
          let normalizedDist = (distance - 0.1) / (0.6 - 0.1);
          normalizedDist = Math.max(0, Math.min(1, normalizedDist));
          targetScale = minScale + normalizedDist * (maxScale - minScale);

          // --- X·ª¨ L√ù ROTATION (M·ªöI: XOAY TR·ª§C Y) ---
          const dy = rightHand.y - leftHand.y;
          const dx = rightHand.x - leftHand.x;

          // T√≠nh g√≥c nghi√™ng c·ªßa tay
          const angle = Math.atan2(dy, dx);

          // G√°n v√†o tr·ª•c Y thay v√¨ tr·ª•c Z
          // Nh√¢n th√™m h·ªá s·ªë (2.5) ƒë·ªÉ xoay nhanh h∆°n, c·∫£m gi√°c nh·∫°y h∆°n
          targetRotationY = angle * 2.5;
        } else {
          isHandDetected = false;
          targetScale = 1;
        }
      }

      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      hands.onResults(onResults);

      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({ image: videoElement }),
        width: 640,
        height: 480,
      });
      cameraUtils.start();

      document.getElementById("colorPicker").addEventListener("input", (e) => {
        material.color.set(e.target.value);
      });

      // --- 5. ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);

        if (isHandDetected) {
          // L√†m m∆∞·ª£t Scale
          currentScale += (targetScale - currentScale) * 0.1;

          // L√†m m∆∞·ª£t Rotation Y (Xoay ngang)
          currentRotationY += (targetRotationY - currentRotationY) * 0.1;
          particles.rotation.y = currentRotationY; // √Åp d·ª•ng v√†o tr·ª•c Y

          // Reset tr·ª•c Z v·ªÅ 0 t·ª´ t·ª´ ƒë·ªÉ qu·∫£ c·∫ßu ƒë·ª©ng th·∫≥ng
          particles.rotation.z += (0 - particles.rotation.z) * 0.05;
        } else {
          // Idle Mode
          const time = Date.now() * 0.001;
          const breathe = Math.sin(time) * 0.05;

          currentScale += (1 - currentScale) * 0.05;
          particles.scale.set(
            currentScale + breathe,
            currentScale + breathe,
            currentScale + breathe
          );

          // T·ª± xoay nh·∫π
          particles.rotation.y += 0.002;
          currentRotationY = particles.rotation.y; // Sync l·∫°i
        }

        particles.scale.set(currentScale, currentScale, currentScale);
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
