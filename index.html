<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Controlled Particles - Rotate & Scale</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: "Segoe UI", sans-serif;
      }

      #input_video {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 160px;
        height: 120px;
        border-radius: 8px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        transform: scaleX(-1);
        z-index: 2;
        opacity: 0.6;
      }

      #ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(30, 30, 30, 0.85);
        padding: 20px;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        z-index: 10;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        width: 220px;
      }

      h2 {
        margin: 0 0 10px 0;
        font-size: 16px;
        font-weight: 600;
        color: #fff;
      }
      p {
        font-size: 13px;
        color: #ccc;
        margin-bottom: 15px;
        line-height: 1.5;
      }
      .instruction {
        font-size: 12px;
        color: #888;
        margin-bottom: 10px;
        font-style: italic;
      }

      .control-group {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 10px;
      }
      input[type="color"] {
        -webkit-appearance: none;
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        padding: 0;
        overflow: hidden;
      }
      input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 50%;
        border: 2px solid #fff;
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ffff;
        font-size: 18px;
        z-index: 20;
        pointer-events: none;
        transition: opacity 0.5s;
        font-family: monospace;
        letter-spacing: 2px;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="loading">ƒêANG T·∫¢I AI...</div>

    <div id="ui-container">
      <h2>ƒêi·ªÅu khi·ªÉn H·∫°t 3D</h2>
      <p>
        ‚ÜîÔ∏è <b>Kho·∫£ng c√°ch:</b> Ph√≥ng to/nh·ªè<br />
        üîÑ <b>Nghi√™ng tay:</b> Xoay kh·ªëi c·∫ßu
      </p>
      <div class="instruction">H√£y ƒë∆∞a c·∫£ 2 b√†n tay l√™n camera</div>
      <div class="control-group">
        <span>M√†u s·∫Øc:</span>
        <input type="color" id="colorPicker" value="#00ffff" />
      </div>
    </div>

    <video id="input_video"></video>
    <div id="canvas-container"></div>

    <script>
      // --- 1. SETUP THREE.JS ---
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050505, 0.002); // S∆∞∆°ng m√π ƒëen cho n·ªÅn t·ªëi

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 90;

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // T·ªëi ∆∞u hi·ªáu nƒÉng
      document.body.appendChild(renderer.domElement);

      // --- 2. T·∫†O H·ªÜ TH·ªêNG H·∫†T ---
      const particleCount = 5000; // TƒÉng s·ªë l∆∞·ª£ng h·∫°t l√™n m·ªôt ch√∫t
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const radius = 30;

      // T·∫°o h√¨nh c·∫ßu Fibonacci
      for (let i = 0; i < particleCount; i++) {
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;

        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(phi);

        positions.push(x, y, z);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3)
      );

      const material = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 1.2,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- 3. BI·∫æN LOGIC ---
      let targetScale = 1;
      let currentScale = 1;
      let targetRotationZ = 0; // G√≥c xoay m·ª•c ti√™u
      let currentRotationZ = 0; // G√≥c xoay hi·ªán t·∫°i (ƒë·ªÉ l√†m m∆∞·ª£t)
      let isHandDetected = false;

      // --- 4. X·ª¨ L√ù MEDIAPIPE ---
      const videoElement = document.getElementById("input_video");

      function onResults(results) {
        document.getElementById("loading").style.opacity = 0;

        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length === 2
        ) {
          isHandDetected = true;

          // L·∫•y m·∫£ng landmark
          let landmarks = results.multiHandLandmarks;

          // QUAN TR·ªåNG: S·∫Øp x·∫øp tay tr√°i/ph·∫£i d·ª±a tr√™n to·∫° ƒë·ªô X
          // Tay tr√°i (tr√™n m√†n h√¨nh) s·∫Ω c√≥ x nh·ªè h∆°n tay ph·∫£i
          landmarks.sort((a, b) => a[8].x - b[8].x);

          const leftHand = landmarks[0][8]; // Ng√≥n tr·ªè tay tr√°i (tr√™n m√†n h√¨nh)
          const rightHand = landmarks[1][8]; // Ng√≥n tr·ªè tay ph·∫£i (tr√™n m√†n h√¨nh)

          // --- X·ª¨ L√ù SCALE (KHO·∫¢NG C√ÅCH) ---
          const distance = Math.sqrt(
            Math.pow(leftHand.x - rightHand.x, 2) +
              Math.pow(leftHand.y - rightHand.y, 2)
          );

          // Map kho·∫£ng c√°ch sang scale
          const minScale = 0.5;
          const maxScale = 4.5;
          let normalizedDist = (distance - 0.1) / (0.6 - 0.1);
          normalizedDist = Math.max(0, Math.min(1, normalizedDist));
          targetScale = minScale + normalizedDist * (maxScale - minScale);

          // --- X·ª¨ L√ù ROTATION (G√ìC NGHI√äNG) ---
          // T√≠nh vector ch√™nh l·ªách gi·ªØa 2 tay
          const dy = rightHand.y - leftHand.y;
          const dx = rightHand.x - leftHand.x;

          // Math.atan2 tr·∫£ v·ªÅ g√≥c t√≠nh b·∫±ng radian
          // L∆∞u √Ω: H·ªá to·∫° ƒë·ªô m√†n h√¨nh Y h∆∞·ªõng xu·ªëng, n√™n ta ƒë·∫£o d·∫•u ho·∫∑c ƒëi·ªÅu ch·ªânh tu·ª≥ c·∫£m gi√°c
          // ·ªû ƒë√¢y ta mu·ªën: Tay ph·∫£i cao h∆°n -> Xoay tr√°i (ng∆∞·ª£c chi·ªÅu kim ƒë·ªìng h·ªì)
          const angle = Math.atan2(dy, dx);

          // G√°n g√≥c m·ª•c ti√™u (nh√¢n th√™m h·ªá s·ªë n·∫øu mu·ªën xoay g·∫Øt h∆°n)
          // -angle ƒë·ªÉ ƒë·ªìng b·ªô c·∫£m gi√°c xoay v√¥ lƒÉng
          targetRotationZ = -angle;
        } else {
          isHandDetected = false;
          // N·∫øu kh√¥ng c√≥ tay, reset t·ª´ t·ª´ ho·∫∑c gi·ªØ nguy√™n
          targetScale = 1;
          // targetRotationZ = 0; // B·ªè comment n·∫øu mu·ªën t·ª± c√¢n b·∫±ng l·∫°i khi b·ªè tay ra
        }
      }

      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      hands.onResults(onResults);

      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({ image: videoElement }),
        width: 640,
        height: 480,
      });
      cameraUtils.start();

      // --- UI ---
      document.getElementById("colorPicker").addEventListener("input", (e) => {
        material.color.set(e.target.value);
      });

      // --- 5. ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);

        if (isHandDetected) {
          // Khi c√≥ tay:
          // 1. Lerp Scale (l√†m m∆∞·ª£t thu ph√≥ng)
          currentScale += (targetScale - currentScale) * 0.1;

          // 2. Lerp Rotation (l√†m m∆∞·ª£t xoay)
          // C√¥ng th·ª©c n√†y gi√∫p xoay m∆∞·ª£t m√† t·ª´ g√≥c hi·ªán t·∫°i sang g√≥c m·ª•c ti√™u
          currentRotationZ += (targetRotationZ - currentRotationZ) * 0.1;

          particles.rotation.z = currentRotationZ;

          // Gi·∫£m t·ªëc ƒë·ªô t·ª± quay tr·ª•c Y khi ƒëang ƒëi·ªÅu khi·ªÉn
          particles.rotation.y += 0.001;
        } else {
          // Khi kh√¥ng c√≥ tay:
          // Hi·ªáu ·ª©ng "Th·ªü"
          const time = Date.now() * 0.001;
          const breathe = Math.sin(time) * 0.05;

          // Scale v·ªÅ m·∫∑c ƒë·ªãnh
          currentScale += (1 - currentScale) * 0.05;
          particles.scale.set(
            currentScale + breathe,
            currentScale + breathe,
            currentScale + breathe
          );

          // T·ª± ƒë·ªông quay idle
          particles.rotation.y += 0.002;
          particles.rotation.z += 0.001;

          // ƒê·ªìng b·ªô bi·∫øn rotation hi·ªán t·∫°i ƒë·ªÉ khi ƒë∆∞a tay v√†o kh√¥ng b·ªã gi·∫≠t
          currentRotationZ = particles.rotation.z;
        }

        // √Åp d·ª•ng scale
        particles.scale.set(currentScale, currentScale, currentScale);

        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
