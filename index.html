<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Hand Particle System</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Segoe UI", sans-serif;
      }

      /* Video ẩn để xử lý logic, hoặc hiện nhỏ để debug */
      #input_video {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 160px;
        height: 120px;
        border-radius: 8px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        transform: scaleX(-1); /* Hiệu ứng gương */
        z-index: 2;
        opacity: 0.7;
      }

      /* Giao diện UI */
      #ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(20, 20, 20, 0.8);
        padding: 20px;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        z-index: 10;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        max-width: 250px;
      }

      h2 {
        margin: 0 0 10px 0;
        font-size: 16px;
        font-weight: 600;
        letter-spacing: 0.5px;
      }
      p {
        font-size: 12px;
        color: #aaa;
        margin-bottom: 15px;
        line-height: 1.4;
      }

      .control-group {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      input[type="color"] {
        -webkit-appearance: none;
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        padding: 0;
        overflow: hidden;
      }
      input[type="color"]::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 50%;
        border: 2px solid white;
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 20px;
        z-index: 20;
        pointer-events: none;
        transition: opacity 0.5s;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="loading">Đang khởi động Camera & AI... vui lòng đợi</div>

    <div id="ui-container">
      <h2>Interactive Particles</h2>
      <p>Sử dụng 2 tay:<br />Gần nhau = Thu nhỏ<br />Xa nhau = Mở rộng</p>
      <div class="control-group">
        <span>Màu hạt:</span>
        <input type="color" id="colorPicker" value="#00ffff" />
      </div>
    </div>

    <video id="input_video"></video>
    <div id="canvas-container"></div>

    <script>
      // --- CẤU HÌNH THREE.JS ---
      const scene = new THREE.Scene();
      // Thêm sương mù nhẹ để tạo chiều sâu
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 100;

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // --- TẠO HỆ THỐNG HẠT (HÌNH CẦU) ---
      const particleCount = 4000;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const originalPositions = []; // Lưu vị trí gốc để tính toán

      const radius = 30;

      for (let i = 0; i < particleCount; i++) {
        // Thuật toán fibonacci sphere để phân bố hạt đều trên mặt cầu
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;

        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(phi);

        positions.push(x, y, z);
        originalPositions.push(x, y, z);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3)
      );

      const material = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 1.5,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- BIẾN TRẠNG THÁI ---
      let targetScale = 1;
      let currentScale = 1;
      let isHandDetected = false;

      // --- XỬ LÝ MEDIAPIPE (NHẬN DIỆN TAY) ---
      const videoElement = document.getElementById("input_video");

      function onResults(results) {
        document.getElementById("loading").style.opacity = 0;

        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length === 2
        ) {
          isHandDetected = true;

          // Lấy tọa độ ngón trỏ của 2 bàn tay
          // Landmark 8 là đầu ngón trỏ
          const hand1 = results.multiHandLandmarks[0][8];
          const hand2 = results.multiHandLandmarks[1][8];

          // Tính khoảng cách Euclide giữa 2 ngón tay (tương đối theo khung hình)
          const distance = Math.sqrt(
            Math.pow(hand1.x - hand2.x, 2) + Math.pow(hand1.y - hand2.y, 2)
          );

          // Map khoảng cách (thường từ 0.05 đến 0.8) sang tỉ lệ scale (từ 0.5 đến 4)
          // Điều chỉnh các số này để cảm giác tay thật hơn
          const minHandDist = 0.1;
          const maxHandDist = 0.6;
          const minScale = 0.5; // Trạng thái thu gọn
          const maxScale = 5.0; // Trạng thái mở rộng

          // Hàm map giá trị
          let normalized =
            (distance - minHandDist) / (maxHandDist - minHandDist);
          normalized = Math.max(0, Math.min(1, normalized)); // Clamp 0-1

          targetScale = minScale + normalized * (maxScale - minScale);
        } else {
          isHandDetected = false;
          // Nếu không có 2 tay, từ từ trở về trạng thái bình thường (hoặc giữ nguyên, tuỳ ý)
          targetScale = 1;
        }
      }

      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        },
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      hands.onResults(onResults);

      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480,
      });
      cameraUtils.start();

      // --- UI CONTROL ---
      const colorPicker = document.getElementById("colorPicker");
      colorPicker.addEventListener("input", (e) => {
        material.color.set(e.target.value);
      });

      // --- ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);

        // 1. Hiệu ứng quay tự động nhẹ nhàng
        particles.rotation.y += 0.002;
        particles.rotation.z += 0.001;

        // 2. Nội suy tuyến tính (Lerp) để chuyển động mượt mà giữa các mức zoom
        currentScale += (targetScale - currentScale) * 0.1;

        // 3. Cập nhật vị trí hạt dựa trên scale
        // Thay vì dùng particles.scale.set (chỉ phóng to cả cụm),
        // ta tính toán lại vị trí để có thể thêm hiệu ứng nhiễu (noise) nếu muốn sau này.
        // Ở đây để tối ưu hiệu năng, ta dùng scale của Mesh
        particles.scale.set(currentScale, currentScale, currentScale);

        // Hiệu ứng "Thở" nhẹ khi không có tay
        if (!isHandDetected) {
          const time = Date.now() * 0.001;
          const breathe = Math.sin(time) * 0.1;
          particles.scale.set(1 + breathe, 1 + breathe, 1 + breathe);
        }

        renderer.render(scene, camera);
      }

      // --- RESIZE HANDLER ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
